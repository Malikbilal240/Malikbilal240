KEY POINTS OF ORACLE DB
PGA ##########################################
PGA is like your own little disk in memory where oracle puts all things you need while using the db
here are main things inside the PGA
sort area, session data, hash join area, cursors, stack
Sort area:
Temporary memory for sorting and ordering data during SQL queries.
Like: Pile of papers you’re sorting.
Session data:
Space for values and variables used only in your database session.
Like: Your notepad and sticky notes.
Hash join area:
Memory used to match data from two tables when joining them.
Like: A second pile where you’re matching customer files with orders.
Cursors:
Details about the SQL statements you have open and are working with.
Like: Bookmarks to jump back to different projects you have open.
Stack:
Memory for handling calculations and running your database code.
Like: Your calculator’s memory for quick math.
==============================
Scenarios when TEMP is used:##########################################
Large sorts (e.g., ORDER BY or GROUP BY on many rows)
Hash joins with huge data sets
Creating indexes on big tables
“Global temporary tables” when their data is larger than PGA can hold
Example:
You run a query that needs to sort 1 million rows, and PGA only fits 500,000.
Oracle sorts 500,000 in memory; the rest gets written to TEMP tablespace on disk, then merged at the end.
-------------------------------------------->>>>>>>>>>>>>>>>>>>>>
Why ORA-01555 Happens
Long queries need to access data as it looked when they started.
The required “undo” history gets overwritten if the system is busy or the undo space is too small.
When undo data needed by the query is gone, you get the ORA-01555 error.
Solutions: How to Prevent ORA-01555
1. Increase Undo Tablespace Size

What: Make your undo tablespace bigger so it can keep more “before” images for longer time periods.
How: Work with your DBA to resize (add more data files or increase size) the undo tablespace.
Why: More space = more undo history retained.

2. Set a Higher undo_retention Value

What: Tell Oracle to try to keep undo data for a longer duration (in seconds).
How:SQLALTER SYSTEM SET UNDO_RETENTION = 28800; -- (for 8 hours, for example)


Why: Longer retention helps support long queries or flashback operations.

3. Tune Long-Running Queries

What: Make your queries faster—so they don’t need undo data for as long.
How:

Add indexes
Break big jobs into smaller steps
Optimize query logic



4. Minimize Unnecessary DML Activity During Reporting

What: If possible, schedule large reports or data exports when few data changes are happening (for example, during off-peak hours).
Why: Fewer changes = slower undo usage = less chance of running out of undo history.

5. Check for Uncommitted Transactions

Stuck or forgotten uncommitted changes can keep undo data locked longer than needed and fill the undo space.
Make sure transactions are regularly committed or rolled back.

6. Use Read-Only or Replicated Environments for Long Reports

If you can, run heavy reports on database replicas or snapshots instead of the main (busy) production database.


Quick Checklist

Make undo tablespace bigger ✔️
Increase undo_retention value ✔️
Tune queries for speed ✔️
Avoid running big queries during busy hours ✔️

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what are the top five wait events...
1. db file sequential read.
what is it?waiting for a single block (row) to be read from disk(usually for an index lookup)
when do you see it?
when the db fetches specific rows - such as looking up an employee in a table by id.
what it means? usually caused by queries that use indexs and sometimes indicates slow disk storage or missing indexes.
2. db file scattered read
what is it? waiting for multiple blocks to be read from disk at once (usually for full table scans)
when do you see it? when oracle needs to read lots or rows from table (for example when running a search without index)
what is means? often means queries are scaning entire tables..possibily because of missing or unused indexes.
3. log file sync
what is it? applications are waiting for changes(commits) to be safely written to the redo (for recovery)
when do you see it? when there are lots of transactios being committed.
what is means? petential bottleneck with disk speed for redo logs, or very frequent committs.
4. db file parrallel write.
what is it?
waiting for multiple writes to be completed to disk at once (the db is saving lots of data at the same time?
when do you see it?
during operations batch updates, deletes or when writing large amounts of data.
what it means? disk write throughput might be a limiting factor.
5.  enq: TX - row lock contention
What is it?
Waiting for a lock to be released on a particular row in a table (another transaction is holding it).
When do you see it?
When multiple sessions try to modify the same row at the same time.
What it means:
Can indicate application design issues, such as too many users editing the same data, causing “blocking.”


